(()=>{var w=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var k=w((_e,Pt)=>{var f=class{constructor(t,s){this.x=t,this.y=s}equals(t){return this.x===t.x&&this.y===t.y}toString(){return`P(${this.x}, ${this.y})`}distance(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}distanceSquared(t){return(this.x-t.x)**2+(this.y-t.y)**2}},b=class n{constructor(t,s){if(!(t instanceof f)||!(s instanceof f))throw new Error("Start and end must be Point instances");this.start=t,this.end=s}equals(t){return t instanceof n?this.start.equals(t.start)&&this.end.equals(t.end):!1}toString(){return`S(${this.start}, ${this.end})`}get lengthSquared(){return this.start.distanceSquared(this.end)}get length(){return this.start.distance(this.end)}get top(){return Math.max(this.start.y,this.end.y)}get bottom(){return Math.min(this.start.y,this.end.y)}get right(){return Math.max(this.start.x,this.end.x)}get left(){return Math.min(this.start.x,this.end.x)}},U=class extends b{constructor(t,s){if(!(t instanceof f)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new f(t.x+s,t.y))}get length(){return this.end.x-this.start.x}},K=class extends b{constructor(t,s){if(!(t instanceof f)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new f(t.x,t.y+s))}get length(){return this.end.y-this.start.y}},H=class n{constructor(t,s,e,i,r=null){if(i<0||e<0)throw new Error("Height and width must be non-negative");this.width=e,this.height=i,this.x=t,this.y=s,this.rid=r}get bottom(){return this.y}get top(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}get cornerTopL(){return new f(this.left,this.top)}get cornerTopR(){return new f(this.right,this.top)}get cornerBotR(){return new f(this.right,this.bottom)}get cornerBotL(){return new f(this.left,this.bottom)}area(){return this.width*this.height}move(t,s){this.x=t,this.y=s}contains(t){return t.y>=this.y&&t.x>=this.x&&t.y+t.height<=this.y+this.height&&t.x+t.width<=this.x+this.width}intersects(t,s=!1){if(s){if(this.bottom>t.top||this.top<t.bottom||this.left>t.right||this.right<t.left)return!1}else if(this.bottom>=t.top||this.top<=t.bottom||this.left>=t.right||this.right<=t.left)return!1;return!0}intersection(t,s=!1){if(!this.intersects(t,s))return null;let e=Math.max(this.bottom,t.bottom),i=Math.max(this.left,t.left),r=Math.min(this.top,t.top),l=Math.min(this.right,t.right);return new n(i,e,l-i,r-e)}join(t){if(this.contains(t))return!0;if(t.contains(this))return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,!0;if(!this.intersects(t,!0))return!1;if(this.left===t.left&&this.width===t.width){let s=Math.min(this.bottom,t.bottom),e=Math.max(this.top,t.top);return this.y=s,this.height=e-s,!0}if(this.bottom===t.bottom&&this.height===t.height){let s=Math.min(this.left,t.left),e=Math.max(this.right,t.right);return this.x=s,this.width=e-s,!0}return!1}};Pt.exports={Point:f,Segment:b,HSegment:U,VSegment:K,Rectangle:H}});var Q=w((de,Tt)=>{var{Rectangle:Gt}=k(),J=class{constructor(t,s,e=!0,i=null){this.width=t,this.height=s,this.rot=e,this.rectangles=[],this.bid=i,this._surface=new Gt(0,0,t,s),this.reset()}get length(){return this.rectangles.length}[Symbol.iterator](){return this.rectangles[Symbol.iterator]()}_fitsSurface(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");if(this.rot&&(t>this.width||s>this.height)){let e=t;t=s,s=e}return!(t>this.width||s>this.height)}getItem(t){return this.rectangles[t]}usedArea(){return this.rectangles.reduce((t,s)=>t+s.area(),0)}fitness(t,s,e=!1){throw new Error("Not implemented")}addRect(t,s,e=null){throw new Error("Not implemented")}rectList(){return this.rectangles.map(t=>[t.x,t.y,t.width,t.height,t.rid])}validatePacking(){let t=new Gt(0,0,this.width,this.height);for(let s of this.rectangles)if(!t.contains(s))throw new Error("Rectangle placed outside surface");if(!(this.rectangles.length<=1)){for(let s=0;s<=this.rectangles.length-2;s++)for(let e=s+1;e<=this.rectangles.length-1;e++)if(this.rectangles[s].intersects(this.rectangles[e]))throw new Error("Rectangle collision detected")}}isEmpty(){return this.rectangles.length===0}reset(){this.rectangles=[]}};Tt.exports=J});var bt=w((pe,At)=>{var{Rectangle:B}=k(),Ht=Q(),Jt=n=>class extends n{constructor(t,s,e=!0,i=!0,...r){super(t,s,e,...r),this._merge=i,this._sections=[],this._add_section(new B(0,0,t,s,null))}_add_section(t){t.rid=0;let s=0;for(;this._merge&&this._sections&&s!==this._sections.length;)s=this._sections.length,this._sections=this._sections.filter(e=>!t.join(e));this._sections.push(t)}_split_horizontal(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,t.width,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,e))}_split_vertical(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,s,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,t.height))}_split(t,s,e){throw new Error("Not implemented")}_section_fitness(t,s,e){throw new Error("Not implemented")}_select_fittest_section(t,s){let e=this._sections.map(u=>{let c=this._section_fitness(u,t,s);return c!==null?[c,u,!1]:null}).filter(u=>u!==null),i=[];this.rot.rot===!0&&(i=this._sections.map(u=>{let c=this._section_fitness(u,s,t);return c!==null?[c,u,!0]:null}).filter(u=>u!==null));let r=[...e,...i];if(r.length===0)return[];let[l,a,p]=r.reduce((u,c)=>c[0]<u[0]?c:u);return[a,p]}addRect(t,s,e=null){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[i,r]=this._select_fittest_section(t,s);if(!i)return null;if(r){let a=t;t=s,s=a}this._sections=this._sections.filter(a=>a!==i),this._split(i,t,s);let l=new B(i.x,i.y,t,s,e);return this.rectangles.push(l),l}fitness(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[e,i]=this._select_fittest_section(t,s);return e?i?this._section_fitness(e,s,t):this._section_fitness(e,t,s):null}reset(){super.reset(),this._sections=[],this._add_section(new B(0,0,this.width,this.height))}},Qt=Jt(Ht),o=class extends Qt{constructor(...t){super(...t)}},X=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},m=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},Y=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},y=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},Z=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},M=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},O=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width<t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Xt=O(o),V=class extends Xt{constructor(...t){super(...t)}},E=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width>=t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Yt=E(o),tt=class extends Yt{constructor(...t){super(...t)}},F=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Zt=F(o),st=class extends Zt{constructor(...t){super(...t)}},v=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Vt=v(o),et=class extends Vt{constructor(...t){super(...t)}},P=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},ts=P(o),nt=class extends ts{constructor(...t){super(...t)}},G=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return s*(t.height-e)>=e*(t.width-s)?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},ss=G(o),it=class extends ss{constructor(...t){super(...t)}},es=O(M(o)),rt=class extends es{constructor(...t){super(...t)}},ns=E(M(o)),ot=class extends ns{constructor(...t){super(...t)}},is=F(M(o)),lt=class extends is{constructor(...t){super(...t)}},rs=v(M(o)),ct=class extends rs{constructor(...t){super(...t)}},os=P(M(o)),ht=class extends os{constructor(...t){super(...t)}},ls=G(M(o)),at=class extends ls{constructor(...t){super(...t)}},cs=O(y(o)),ut=class extends cs{constructor(...t){super(...t)}},hs=E(y(o)),ft=class extends hs{constructor(...t){super(...t)}},as=F(y(o)),_t=class extends as{constructor(...t){super(...t)}},us=v(y(o)),dt=class extends us{constructor(...t){super(...t)}},fs=P(y(o)),pt=class extends fs{constructor(...t){super(...t)}},_s=G(y(o)),xt=class extends _s{constructor(...t){super(...t)}},ds=O(m(o)),Bt=class extends ds{constructor(...t){super(...t)}},ps=E(m(o)),gt=class extends ps{constructor(...t){super(...t)}},xs=F(m(o)),wt=class extends xs{constructor(...t){super(...t)}},Bs=v(m(o)),mt=class extends Bs{constructor(...t){super(...t)}},gs=P(m(o)),yt=class extends gs{constructor(...t){super(...t)}},ws=G(m(o)),Mt=class extends ws{constructor(...t){super(...t)}};At.exports={Guillotine:o,GuillotineBaf:X,GuillotineBlsf:Y,GuillotineBssf:Z,GuillotineSas:V,GuillotineLas:tt,GuillotineSlas:st,GuillotineLlas:et,GuillotineMaxas:nt,GuillotineMinas:it,GuillotineBssfSas:rt,GuillotineBssfLas:ot,GuillotineBssfSlas:lt,GuillotineBssfLlas:ct,GuillotineBssfMaxas:ht,GuillotineBssfMinas:at,GuillotineBlsfSas:ut,GuillotineBlsfLas:ft,GuillotineBlsfSlas:_t,GuillotineBlsfLlas:dt,GuillotineBlsfMaxas:pt,GuillotineBlsfMinas:xt,GuillotineBafSas:Bt,GuillotineBafLas:gt,GuillotineBafSlas:wt,GuillotineBafLlas:mt,GuillotineBafMaxas:yt,GuillotineBafMinas:Mt}});var Nt=w((ke,Lt)=>{var{GuillotineBssfSas:C}=bt();function ms(n,t){return Number(Math.ceil(n*Math.pow(10,t))/Math.pow(10,t))}var qt=n=>[...n].sort((t,s)=>s[0]*s[1]-t[0]*t[1]),ys=n=>[...n].sort((t,s)=>s[0]+s[1]-(t[0]+t[1])),Ms=n=>[...n].sort((t,s)=>Math.abs(s[0]-s[1])-Math.abs(t[0]-t[1])),bs=n=>[...n].sort((t,s)=>{let[e,i]=[Math.min(t[0],t[1]),Math.max(t[0],t[1])],[r,l]=[Math.min(s[0],s[1]),Math.max(s[0],s[1])];return r-e||l-i}),Rs=n=>[...n].sort((t,s)=>{let[e,i]=[Math.max(t[0],t[1]),Math.min(t[0],t[1])],[r,l]=[Math.max(s[0],s[1]),Math.min(s[0],s[1])];return r-e||l-i}),Ss=n=>[...n].sort((t,s)=>s[0]/s[1]-t[0]/t[1]),Rt=n=>[...n],T={Online:0,Offline:1,properties:{0:{name:"Online"},1:{name:"Offline"}}},d={BNF:0,BFF:1,BBF:2,Global:3,properties:{0:{name:"BNF"},1:{name:"BFF"},2:{name:"BBF"},3:{name:"Global"}}},A=class{constructor(t,s,e,i,...r){this._width=t,this._height=s,this._count=e,this._packAlgo=i,this._algoArgs=r,this._refBin=null}_createBin(){return new this._packAlgo(this._width,this._height,...this._algoArgs)}isEmpty(){return this._count<1}fitness(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin.fitness(t,s)}fitsInside(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin._fitsSurface(t,s)}newBin(){return this._count>0?(this._count--,this._createBin()):null}},_=class{constructor({packAlgo:t=C,rotation:s=!0}){this._rotation=s,this._packAlgo=t,this.reset()}*[Symbol.iterator](){yield*[...this._closedBins,...this._openBins]}get length(){return this._closedBins.length+this._openBins.length}_newOpenBin(t=null,s=null,e=null){let i=new Set,r=null;for(let[l,a]of Object.entries(this._emptyBins))if(a.fitsInside(t,s)&&(r=a.newBin(),!!r)){this._openBins.push(r),a.isEmpty()&&i.add(l);break}return i.forEach(l=>delete this._emptyBins[l]),r}addBin(t,s,e=1,i={}){i.rot=this._rotation;let r=new A(t,s,e,this._packAlgo,i);this._emptyBins[this._binCount++]=r}rectList(){let t=[],s=0;for(let e of this){for(let i of e)t.push([s,i.x,i.y,i.width,i.height,i.rid]);s++}return t}binList(){return[...this].map(t=>[t.width,t.height])}validatePacking(){for(let t of this)t.validatePacking()}reset(){this._closedBins=[],this._openBins=[],this._emptyBins=new Map,this._binCount=0}},$=n=>class extends n{constructor({packAlgo:t=C,sortAlgo:s=Rt,rotation:e=!0}={}){super({packAlgo:t,rotation:e}),this._sortAlgo=s,this._availBins=[],this._availRect=[],this._sortedRect=[]}addBin(t,s,e=1,i={}){this._availBins.push([t,s,e,i])}addRect(t,s,e=null){this._availRect.push([t,s,e])}addRectOffline(t,s,e=null){this._availRect.push([t,s,e])}_isEverythingReady(){return this._availRect.length>0&&this._availBins.length>0}pack(){if(this.reset(),!!this._isEverythingReady()){for(let t=0;t<this._availBins.length;t++){let[s,e,i,r]=this._availBins[t];super.addBin(s,e,i,r)}this._sortedRect=this._sortAlgo(this._availRect);for(let t of this._sortedRect)super.addRect(...t)}}},ks=$(_),q=class extends ks{constructor(...t){super(...t)}},R=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(;;){if(this._openBins.length===0&&!this._newOpenBin(t,s,e))return null;let i=this._openBins[0].addRect(t,s,e);if(i)return i;let r=this._openBins.shift();this._closedBins.push(r)}}},St=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(let i of this._openBins){let r=i.addRect(t,s,e);if(r)return r}for(;;){let i=this._newOpenBin(t,s,e);if(!i)return null;let r=i.addRect(t,s,e);if(r)return r}}},kt=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){let i=this._openBins.map(r=>[r.fitness(t,s),r]).filter(([r])=>r!==null);if(i.length>0){let[r,l]=i.reduce((a,p)=>p[0]<a[0]?p:a);return l.addRect(t,s,e),!0}for(;;){let r=this._newOpenBin(t,s,e);if(!r)return!1;if(r.addRect(t,s,e))return!0}}},Os=$(R(_)),L=class extends Os{constructor(...t){super(...t)}},Es=$(St(_)),N=class extends Es{constructor(...t){super(...t)}},Fs=$(kt(_)),I=class extends Fs{constructor(...t){super(...t)}},vs=R(_),j=class extends vs{constructor(...t){super(...t)}},Ps=St(_),z=class extends Ps{constructor(...t){super(...t)}},Gs=kt(_),D=class extends Gs{constructor(...t){super(...t)}},Ts=R(q),W=class extends Ts{constructor({packAlgo:t=C,rotation:s=!0}={}){super({packAlgo:t,sortAlgo:Rt,rotation:s})}_findBestFit(t){let s=Object.entries(this._sortedRect).map(([r,l])=>[t.fitness(l[0],l[1]),r]).filter(([r])=>r!==null);if(s.length===0)return null;let[e,i]=s.reduce((r,l)=>l[0]<r[0]?l:r);return i}_newOpenBin(t){let s=new Set,e=null;for(let[i,r]of Object.entries(this._emptyBins)){let l=!1;for(let a of Object.values(t))if(r.fitsInside(a[0],a[1])){l=!0;break}if(!l){s.add(i);continue}if(e=r.newBin(),!!e){this._openBins.push(e),r.isEmpty()&&s.add(i);break}}for(let i of s)delete this._emptyBins[i];return e}pack(){if(this.reset(),!!this._isEverythingReady())for(this._sortedRect=Object.fromEntries(this._sortAlgo(this._availRect).map((t,s)=>[s,t]));Object.keys(this._sortedRect).length>0;){let t=this._newOpenBin(this._sortedRect);if(!t)break;for(;;){let s=this._findBestFit(t);if(!s){let i=this._openBins.shift();this._closedBins.push(i);break}let e=this._sortedRect[s];delete this._sortedRect[s],R.prototype.addRect.call(this,...e)}}}};function As({mode:n=T.Offline,binAlgo:t=d.BBF,packAlgo:s=C,sortAlgo:e=qt,rotation:i=!0}={}){let r=null;if(n===T.Online)switch(e=null,t){case d.BNF:r=j;break;case d.BFF:r=z;break;case d.BBF:r=D;break;default:throw new Error("Unsupported bin selection heuristic")}else if(n===T.Offline)switch(t){case d.BNF:r=L;break;case d.BFF:r=N;break;case d.BBF:r=I;break;case d.Global:r=W,e=null;break;default:throw new Error("Unsupported bin selection heuristic")}else throw new Error("Unknown packing mode");return e?new r({packAlgo:s,sortAlgo:e,rotation:i}):new r({packAlgo:s,rotation:i})}Lt.exports={float2dec:ms,SORT_AREA:qt,SORT_PERI:ys,SORT_DIFF:Ms,SORT_SSIDE:bs,SORT_LSIDE:Rs,SORT_RATIO:Ss,SORT_NONE:Rt,BinFactory:A,PackerBNFMixin:R,PackerBFFMixin:St,PackerBBFMixin:kt,PackerOnline:_,Packer:q,PackerBNF:L,PackerBFF:N,PackerBBF:I,PackerOnlineBNF:j,PackerOnlineBFF:z,PackerOnlineBBF:D,PackerGlobal:W,PackingMode:T,PackingBin:d,newPacker:As}});var jt=w((Pe,It)=>{var{Rectangle:x}=k(),qs=Q(),g=class extends qs{constructor(t,s,e=!0,...i){super(t,s,e,...i),this._max_rects=[new x(0,0,t,s)]}_rect_fitness(t,s,e){return s<=t.width&&e<=t.height?0:null}_select_position(t,s){if(!this._max_rects.length)return[null,null];let e=this._max_rects.map(c=>{let h=this._rect_fitness(c,t,s);return h!==null?[h,t,s,c]:null}).filter(c=>c!==null),i=[];this.rot&&(i=this._max_rects.map(c=>{let h=this._rect_fitness(c,s,t);return h!==null?[h,s,t,c]:null}).filter(c=>c!==null));let r=[...e,...i];if(r.length===0)return[null,null];let[l,a,p,u]=r.reduce((c,h)=>h[0]<c[0]?h:c);return[new x(u.x,u.y,a,p),u]}_generate_splits(t,s){let e=[];return s.x>t.x&&e.push(new x(t.x,t.y,s.x-t.x,t.height)),s.x+s.width<t.x+t.width&&e.push(new x(s.x+s.width,t.y,t.x+t.width-(s.x+s.width),t.height)),s.y+s.height<t.y+t.height&&e.push(new x(t.x,s.y+s.height,t.width,t.y+t.height-(s.y+s.height))),s.y>t.y&&e.push(new x(t.x,t.y,t.width,s.y-t.y)),e}_split(t){let s=[];for(let e of this._max_rects)e.intersects(t)?s.push(...this._generate_splits(e,t)):s.push(e);this._max_rects=s}_remove_duplicates(){let t=new Set;for(let s=0;s<this._max_rects.length;s++)for(let e=s+1;e<this._max_rects.length;e++){let i=this._max_rects[s],r=this._max_rects[e];i.contains(r)?t.add(r):r.contains(i)&&t.add(i)}this._max_rects=this._max_rects.filter(s=>!t.has(s))}fitness(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[e,i]=this._select_position(t,s);return e?this._rect_fitness(i,e.width,e.height):null}addRect(t,s,e=null){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[i,r]=this._select_position(t,s);return i?(this._split(i),this._remove_duplicates(),i.rid=e,this.rectangles.push(i),i):null}reset(){super.reset(),this._max_rects=[new x(0,0,this.width,this.height)]}},Ot=class extends g{_select_position(t,s){if(!this._max_rects.length)return[null,null];let e=this._max_rects.map(h=>this._rect_fitness(h,t,s)!==null?[h.y+s,h.x,t,s,h]:null).filter(h=>h!==null),i=[];this.rot&&(i=this._max_rects.map(h=>this._rect_fitness(h,s,t)!==null?[h.y+t,h.x,s,t,h]:null).filter(h=>h!==null));let r=[...e,...i];if(r.length===0)return[null,null];let[l,a,p,u,c]=r.reduce((h,S)=>S[0]<h[0]?S:h);return[new x(c.x,c.y,p,u),c]}},Et=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},Ft=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:t.width*t.height-s*e}},vt=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}};It.exports={MaxRects:g,MaxRectsBl:Ot,MaxRectsBssf:Et,MaxRectsBaf:Ft,MaxRectsBlsf:vt}});var ue=w((Ge,Kt)=>{var{GuillotineBssfSas:zt,GuillotineBssfLas:Ls,GuillotineBssfSlas:Ns,GuillotineBssfLlas:Is,GuillotineBssfMaxas:js,GuillotineBssfMinas:zs,GuillotineBlsfSas:Ds,GuillotineBlsfLas:Ws,GuillotineBlsfSlas:Cs,GuillotineBlsfLlas:$s,GuillotineBlsfMaxas:Us,GuillotineBlsfMinas:Ks,GuillotineBafSas:Hs,GuillotineBafLas:Js,GuillotineBafSlas:Qs,GuillotineBafLlas:Xs,GuillotineBafMaxas:Ys,GuillotineBafMinas:Zs}=bt(),{float2dec:Vs,SORT_AREA:Dt,SORT_PERI:te,SORT_DIFF:se,SORT_SSIDE:ee,SORT_LSIDE:ne,SORT_RATIO:ie,SORT_NONE:re,BinFactory:oe,PackerBNFMixin:le,PackerBFFMixin:ce,PackerBBFMixin:he,PackerOnline:ae,PackingMode:Wt,PackingBin:Ct,newPacker:$t}=Nt(),{MaxRectsBl:Ut}=jt();Kt.exports={GuillotineBssfSas:zt,GuillotineBssfLas:Ls,GuillotineBssfSlas:Ns,GuillotineBssfLlas:Is,GuillotineBssfMaxas:js,GuillotineBssfMinas:zs,GuillotineBlsfSas:Ds,GuillotineBlsfLas:Ws,GuillotineBlsfSlas:Cs,GuillotineBlsfLlas:$s,GuillotineBlsfMaxas:Us,GuillotineBlsfMinas:Ks,GuillotineBafSas:Hs,GuillotineBafLas:Js,GuillotineBafSlas:Qs,GuillotineBafLlas:Xs,GuillotineBafMaxas:Ys,GuillotineBafMinas:Zs,MaxRectsBl:Ut,float2dec:Vs,SORT_AREA:Dt,SORT_PERI:te,SORT_DIFF:se,SORT_SSIDE:ee,SORT_LSIDE:ne,SORT_RATIO:ie,SORT_NONE:re,BinFactory:oe,PackerBNFMixin:le,PackerBFFMixin:ce,PackerBBFMixin:he,PackerOnline:ae,PackingMode:Wt,PackingBin:Ct,newPacker:$t};typeof window<"u"&&(window.newPacker=$t,window.PackingMode=Wt,window.PackingBin=Ct,window.SORT_AREA=Dt,window.GuillotineBssfSas=zt,window.MaxRectsBl=Ut)});ue();})();
