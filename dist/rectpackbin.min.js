(()=>{var w=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var k=w((xe,Pt)=>{var f=class{constructor(t,s){this.x=t,this.y=s}equals(t){return this.x===t.x&&this.y===t.y}toString(){return`P(${this.x}, ${this.y})`}distance(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}distanceSquared(t){return(this.x-t.x)**2+(this.y-t.y)**2}},R=class n{constructor(t,s){if(!(t instanceof f)||!(s instanceof f))throw new Error("Start and end must be Point instances");this.start=t,this.end=s}equals(t){return t instanceof n?this.start.equals(t.start)&&this.end.equals(t.end):!1}toString(){return`S(${this.start}, ${this.end})`}get lengthSquared(){return this.start.distanceSquared(this.end)}get length(){return this.start.distance(this.end)}get top(){return Math.max(this.start.y,this.end.y)}get bottom(){return Math.min(this.start.y,this.end.y)}get right(){return Math.max(this.start.x,this.end.x)}get left(){return Math.min(this.start.x,this.end.x)}},U=class extends R{constructor(t,s){if(!(t instanceof f)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new f(t.x+s,t.y))}get length(){return this.end.x-this.start.x}},K=class extends R{constructor(t,s){if(!(t instanceof f)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new f(t.x,t.y+s))}get length(){return this.end.y-this.start.y}},H=class n{constructor(t,s,e,i,r=null){if(i<0||e<0)throw new Error("Height and width must be non-negative");this.width=e,this.height=i,this.x=t,this.y=s,this.rid=r}get bottom(){return this.y}get top(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}get cornerTopL(){return new f(this.left,this.top)}get cornerTopR(){return new f(this.right,this.top)}get cornerBotR(){return new f(this.right,this.bottom)}get cornerBotL(){return new f(this.left,this.bottom)}area(){return this.width*this.height}move(t,s){this.x=t,this.y=s}contains(t){return t.y>=this.y&&t.x>=this.x&&t.y+t.height<=this.y+this.height&&t.x+t.width<=this.x+this.width}intersects(t,s=!1){if(s){if(this.bottom>t.top||this.top<t.bottom||this.left>t.right||this.right<t.left)return!1}else if(this.bottom>=t.top||this.top<=t.bottom||this.left>=t.right||this.right<=t.left)return!1;return!0}intersection(t,s=!1){if(!this.intersects(t,s))return null;let e=Math.max(this.bottom,t.bottom),i=Math.max(this.left,t.left),r=Math.min(this.top,t.top),l=Math.min(this.right,t.right);return new n(i,e,l-i,r-e)}join(t){if(this.contains(t))return!0;if(t.contains(this))return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,!0;if(!this.intersects(t,!0))return!1;if(this.left===t.left&&this.width===t.width){let s=Math.min(this.bottom,t.bottom),e=Math.max(this.top,t.top);return this.y=s,this.height=e-s,!0}if(this.bottom===t.bottom&&this.height===t.height){let s=Math.min(this.left,t.left),e=Math.max(this.right,t.right);return this.x=s,this.width=e-s,!0}return!1}};Pt.exports={Point:f,Segment:R,HSegment:U,VSegment:K,Rectangle:H}});var Q=w((Be,Tt)=>{var{Rectangle:Gt}=k(),J=class{constructor(t,s,e=!0,i=null){this.width=t,this.height=s,this.rot=e,this.rectangles=[],this.bid=i,this._surface=new Gt(0,0,t,s),this.reset()}get length(){return this.rectangles.length}[Symbol.iterator](){return this.rectangles[Symbol.iterator]()}_fitsSurface(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");if(this.rot&&(t>this.width||s>this.height)){let e=t;t=s,s=e}return!(t>this.width||s>this.height)}getItem(t){return this.rectangles[t]}usedArea(){return this.rectangles.reduce((t,s)=>t+s.area(),0)}fitness(t,s,e=!1){throw new Error("Not implemented")}addRect(t,s,e=null){throw new Error("Not implemented")}rectList(){return this.rectangles.map(t=>[t.x,t.y,t.width,t.height,t.rid])}validatePacking(){let t=new Gt(0,0,this.width,this.height);for(let s of this.rectangles)if(!t.contains(s))throw new Error("Rectangle placed outside surface");if(!(this.rectangles.length<=1)){for(let s=0;s<=this.rectangles.length-2;s++)for(let e=s+1;e<=this.rectangles.length-1;e++)if(this.rectangles[s].intersects(this.rectangles[e]))throw new Error("Rectangle collision detected")}}isEmpty(){return this.rectangles.length===0}reset(){this.rectangles=[]}};Tt.exports=J});var Rt=w((ge,At)=>{var{Rectangle:B}=k(),Xt=Q(),Yt=n=>class extends n{constructor(t,s,e=!0,i=!0,...r){super(t,s,e,...r),this._merge=i,this._sections=[],this._add_section(new B(0,0,t,s,null))}_add_section(t){t.rid=0;let s=0;for(;this._merge&&this._sections&&s!==this._sections.length;)s=this._sections.length,this._sections=this._sections.filter(e=>!t.join(e));this._sections.push(t)}_split_horizontal(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,t.width,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,e))}_split_vertical(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,s,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,t.height))}_split(t,s,e){throw new Error("Not implemented")}_section_fitness(t,s,e){throw new Error("Not implemented")}_select_fittest_section(t,s){let e=this._sections.map(u=>{let c=this._section_fitness(u,t,s);return c!==null?[c,u,!1]:null}).filter(u=>u!==null),i=[];this.rot.rot===!0&&(i=this._sections.map(u=>{let c=this._section_fitness(u,s,t);return c!==null?[c,u,!0]:null}).filter(u=>u!==null));let r=[...e,...i];if(r.length===0)return[];let[l,h,p]=r.reduce((u,c)=>c[0]<u[0]?c:u);return[h,p]}addRect(t,s,e=null){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[i,r]=this._select_fittest_section(t,s);if(!i)return null;if(r){let h=t;t=s,s=h}this._sections=this._sections.filter(h=>h!==i),this._split(i,t,s);let l=new B(i.x,i.y,t,s,e);return this.rectangles.push(l),l}fitness(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[e,i]=this._select_fittest_section(t,s);return e?i?this._section_fitness(e,s,t):this._section_fitness(e,t,s):null}reset(){super.reset(),this._sections=[],this._add_section(new B(0,0,this.width,this.height))}},Zt=Yt(Xt),o=class extends Zt{constructor(...t){super(...t)}},X=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},m=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},Y=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},y=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},Z=class extends o{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},M=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},O=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width<t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Vt=O(o),V=class extends Vt{constructor(...t){super(...t)}},E=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width>=t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},ts=E(o),tt=class extends ts{constructor(...t){super(...t)}},F=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},ss=F(o),st=class extends ss{constructor(...t){super(...t)}},v=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},es=v(o),et=class extends es{constructor(...t){super(...t)}},P=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},ns=P(o),nt=class extends ns{constructor(...t){super(...t)}},G=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return s*(t.height-e)>=e*(t.width-s)?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},is=G(o),it=class extends is{constructor(...t){super(...t)}},rs=O(M(o)),rt=class extends rs{constructor(...t){super(...t)}},os=E(M(o)),ot=class extends os{constructor(...t){super(...t)}},ls=F(M(o)),lt=class extends ls{constructor(...t){super(...t)}},cs=v(M(o)),ct=class extends cs{constructor(...t){super(...t)}},as=P(M(o)),at=class extends as{constructor(...t){super(...t)}},hs=G(M(o)),ht=class extends hs{constructor(...t){super(...t)}},us=O(y(o)),ut=class extends us{constructor(...t){super(...t)}},fs=E(y(o)),ft=class extends fs{constructor(...t){super(...t)}},_s=F(y(o)),_t=class extends _s{constructor(...t){super(...t)}},ds=v(y(o)),dt=class extends ds{constructor(...t){super(...t)}},ps=P(y(o)),pt=class extends ps{constructor(...t){super(...t)}},xs=G(y(o)),xt=class extends xs{constructor(...t){super(...t)}},Bs=O(m(o)),Bt=class extends Bs{constructor(...t){super(...t)}},gs=E(m(o)),gt=class extends gs{constructor(...t){super(...t)}},ws=F(m(o)),wt=class extends ws{constructor(...t){super(...t)}},ms=v(m(o)),mt=class extends ms{constructor(...t){super(...t)}},ys=P(m(o)),yt=class extends ys{constructor(...t){super(...t)}},Ms=G(m(o)),Mt=class extends Ms{constructor(...t){super(...t)}};At.exports={Guillotine:o,GuillotineBaf:X,GuillotineBlsf:Y,GuillotineBssf:Z,GuillotineSas:V,GuillotineLas:tt,GuillotineSlas:st,GuillotineLlas:et,GuillotineMaxas:nt,GuillotineMinas:it,GuillotineBssfSas:rt,GuillotineBssfLas:ot,GuillotineBssfSlas:lt,GuillotineBssfLlas:ct,GuillotineBssfMaxas:at,GuillotineBssfMinas:ht,GuillotineBlsfSas:ut,GuillotineBlsfLas:ft,GuillotineBlsfSlas:_t,GuillotineBlsfLlas:dt,GuillotineBlsfMaxas:pt,GuillotineBlsfMinas:xt,GuillotineBafSas:Bt,GuillotineBafLas:gt,GuillotineBafSlas:wt,GuillotineBafLlas:mt,GuillotineBafMaxas:yt,GuillotineBafMinas:Mt}});var Nt=w((Fe,Lt)=>{var{GuillotineBssfSas:C}=Rt();function Rs(n,t){return Number(Math.ceil(n*Math.pow(10,t))/Math.pow(10,t))}var qt=n=>[...n].sort((t,s)=>s[0]*s[1]-t[0]*t[1]),bs=n=>[...n].sort((t,s)=>s[0]+s[1]-(t[0]+t[1])),Ss=n=>[...n].sort((t,s)=>Math.abs(s[0]-s[1])-Math.abs(t[0]-t[1])),ks=n=>[...n].sort((t,s)=>{let[e,i]=[Math.min(t[0],t[1]),Math.max(t[0],t[1])],[r,l]=[Math.min(s[0],s[1]),Math.max(s[0],s[1])];return r-e||l-i}),Os=n=>[...n].sort((t,s)=>{let[e,i]=[Math.max(t[0],t[1]),Math.min(t[0],t[1])],[r,l]=[Math.max(s[0],s[1]),Math.min(s[0],s[1])];return r-e||l-i}),Es=n=>[...n].sort((t,s)=>s[0]/s[1]-t[0]/t[1]),bt=n=>[...n],T={Online:0,Offline:1,properties:{0:{name:"Online"},1:{name:"Offline"}}},d={BNF:0,BFF:1,BBF:2,Global:3,properties:{0:{name:"BNF"},1:{name:"BFF"},2:{name:"BBF"},3:{name:"Global"}}},A=class{constructor(t,s,e,i,...r){this._width=t,this._height=s,this._count=e,this._packAlgo=i,this._algoArgs=r,this._refBin=null}_createBin(){return new this._packAlgo(this._width,this._height,...this._algoArgs)}isEmpty(){return this._count<1}fitness(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin.fitness(t,s)}fitsInside(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin._fitsSurface(t,s)}newBin(){return this._count>0?(this._count--,this._createBin()):null}},_=class{constructor({packAlgo:t=C,rotation:s=!0}){this._rotation=s,this._packAlgo=t,this.reset()}*[Symbol.iterator](){yield*[...this._closedBins,...this._openBins]}get length(){return this._closedBins.length+this._openBins.length}_newOpenBin(t=null,s=null,e=null){let i=new Set,r=null;for(let[l,h]of Object.entries(this._emptyBins))if(h.fitsInside(t,s)&&(r=h.newBin(),!!r)){this._openBins.push(r),h.isEmpty()&&i.add(l);break}return i.forEach(l=>delete this._emptyBins[l]),r}addBin(t,s,e=1,i={}){i.rot=this._rotation;let r=new A(t,s,e,this._packAlgo,i);this._emptyBins[this._binCount++]=r}rectList(){let t=[],s=0;for(let e of this){for(let i of e)t.push([s,i.x,i.y,i.width,i.height,i.rid]);s++}return t}binList(){return[...this].map(t=>[t.width,t.height])}validatePacking(){for(let t of this)t.validatePacking()}reset(){this._closedBins=[],this._openBins=[],this._emptyBins=new Map,this._binCount=0}},$=n=>class extends n{constructor({packAlgo:t=C,sortAlgo:s=bt,rotation:e=!0}={}){super({packAlgo:t,rotation:e}),this._sortAlgo=s,this._availBins=[],this._availRect=[],this._sortedRect=[]}addBin(t,s,e=1,i={}){this._availBins.push([t,s,e,i])}addRect(t,s,e=null){this._availRect.push([t,s,e])}addRectOffline(t,s,e=null){this._availRect.push([t,s,e])}_isEverythingReady(){return this._availRect.length>0&&this._availBins.length>0}pack(){if(this.reset(),!!this._isEverythingReady()){for(let t=0;t<this._availBins.length;t++){let[s,e,i,r]=this._availBins[t];super.addBin(s,e,i,r)}this._sortedRect=this._sortAlgo(this._availRect);for(let t of this._sortedRect)super.addRect(...t)}}},Fs=$(_),q=class extends Fs{constructor(...t){super(...t)}},b=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(;;){if(this._openBins.length===0&&!this._newOpenBin(t,s,e))return null;let i=this._openBins[0].addRect(t,s,e);if(i)return i;let r=this._openBins.shift();this._closedBins.push(r)}}},St=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(let i of this._openBins){let r=i.addRect(t,s,e);if(r)return r}for(;;){let i=this._newOpenBin(t,s,e);if(!i)return null;let r=i.addRect(t,s,e);if(r)return r}}},kt=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){let i=this._openBins.map(r=>[r.fitness(t,s),r]).filter(([r])=>r!==null);if(i.length>0){let[r,l]=i.reduce((h,p)=>p[0]<h[0]?p:h);return l.addRect(t,s,e),!0}for(;;){let r=this._newOpenBin(t,s,e);if(!r)return!1;if(r.addRect(t,s,e))return!0}}},vs=$(b(_)),L=class extends vs{constructor(...t){super(...t)}},Ps=$(St(_)),N=class extends Ps{constructor(...t){super(...t)}},Gs=$(kt(_)),I=class extends Gs{constructor(...t){super(...t)}},Ts=b(_),j=class extends Ts{constructor(...t){super(...t)}},As=St(_),z=class extends As{constructor(...t){super(...t)}},qs=kt(_),D=class extends qs{constructor(...t){super(...t)}},Ls=b(q),W=class extends Ls{constructor({packAlgo:t=C,rotation:s=!0}={}){super({packAlgo:t,sortAlgo:bt,rotation:s})}_findBestFit(t){let s=Object.entries(this._sortedRect).map(([r,l])=>[t.fitness(l[0],l[1]),r]).filter(([r])=>r!==null);if(s.length===0)return null;let[e,i]=s.reduce((r,l)=>l[0]<r[0]?l:r);return i}_newOpenBin(t){let s=new Set,e=null;for(let[i,r]of Object.entries(this._emptyBins)){let l=!1;for(let h of Object.values(t))if(r.fitsInside(h[0],h[1])){l=!0;break}if(!l){s.add(i);continue}if(e=r.newBin(),!!e){this._openBins.push(e),r.isEmpty()&&s.add(i);break}}for(let i of s)delete this._emptyBins[i];return e}pack(){if(this.reset(),!!this._isEverythingReady())for(this._sortedRect=Object.fromEntries(this._sortAlgo(this._availRect).map((t,s)=>[s,t]));Object.keys(this._sortedRect).length>0;){let t=this._newOpenBin(this._sortedRect);if(!t)break;for(;;){let s=this._findBestFit(t);if(!s){let i=this._openBins.shift();this._closedBins.push(i);break}let e=this._sortedRect[s];delete this._sortedRect[s],b.prototype.addRect.call(this,...e)}}}};function Ns({mode:n=T.Offline,binAlgo:t=d.BBF,packAlgo:s=C,sortAlgo:e=qt,rotation:i=!0}={}){let r=null;if(n===T.Online)switch(e=null,t){case d.BNF:r=j;break;case d.BFF:r=z;break;case d.BBF:r=D;break;default:throw new Error("Unsupported bin selection heuristic")}else if(n===T.Offline)switch(t){case d.BNF:r=L;break;case d.BFF:r=N;break;case d.BBF:r=I;break;case d.Global:r=W,e=null;break;default:throw new Error("Unsupported bin selection heuristic")}else throw new Error("Unknown packing mode");return e?new r({packAlgo:s,sortAlgo:e,rotation:i}):new r({packAlgo:s,rotation:i})}Lt.exports={float2dec:Rs,SORT_AREA:qt,SORT_PERI:bs,SORT_DIFF:Ss,SORT_SSIDE:ks,SORT_LSIDE:Os,SORT_RATIO:Es,SORT_NONE:bt,BinFactory:A,PackerBNFMixin:b,PackerBFFMixin:St,PackerBBFMixin:kt,PackerOnline:_,Packer:q,PackerBNF:L,PackerBFF:N,PackerBBF:I,PackerOnlineBNF:j,PackerOnlineBFF:z,PackerOnlineBBF:D,PackerGlobal:W,PackingMode:T,PackingBin:d,newPacker:Ns}});var jt=w((Ae,It)=>{var{Rectangle:x}=k(),Is=Q(),g=class extends Is{constructor(t,s,e=!0,...i){super(t,s,e,...i),this._max_rects=[new x(0,0,t,s)]}_rect_fitness(t,s,e){return s<=t.width&&e<=t.height?0:null}_select_position(t,s){if(!this._max_rects.length)return[null,null];let e=this._max_rects.map(c=>{let a=this._rect_fitness(c,t,s);return a!==null?[a,t,s,c]:null}).filter(c=>c!==null),i=[];this.rot&&(i=this._max_rects.map(c=>{let a=this._rect_fitness(c,s,t);return a!==null?[a,s,t,c]:null}).filter(c=>c!==null));let r=[...e,...i];if(r.length===0)return[null,null];let[l,h,p,u]=r.reduce((c,a)=>a[0]<c[0]?a:c);return[new x(u.x,u.y,h,p),u]}_generate_splits(t,s){let e=[];return s.x>t.x&&e.push(new x(t.x,t.y,s.x-t.x,t.height)),s.x+s.width<t.x+t.width&&e.push(new x(s.x+s.width,t.y,t.x+t.width-(s.x+s.width),t.height)),s.y+s.height<t.y+t.height&&e.push(new x(t.x,s.y+s.height,t.width,t.y+t.height-(s.y+s.height))),s.y>t.y&&e.push(new x(t.x,t.y,t.width,s.y-t.y)),e}_split(t){let s=[];for(let e of this._max_rects)e.intersects(t)?s.push(...this._generate_splits(e,t)):s.push(e);this._max_rects=s}_remove_duplicates(){let t=new Set;for(let s=0;s<this._max_rects.length;s++)for(let e=s+1;e<this._max_rects.length;e++){let i=this._max_rects[s],r=this._max_rects[e];i.contains(r)?t.add(r):r.contains(i)&&t.add(i)}this._max_rects=this._max_rects.filter(s=>!t.has(s))}fitness(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[e,i]=this._select_position(t,s);return e?this._rect_fitness(i,e.width,e.height):null}addRect(t,s,e=null){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[i,r]=this._select_position(t,s);return i?(this._split(i),this._remove_duplicates(),i.rid=e,this.rectangles.push(i),i):null}reset(){super.reset(),this._max_rects=[new x(0,0,this.width,this.height)]}},Ot=class extends g{_select_position(t,s){if(!this._max_rects.length)return[null,null];let e=this._max_rects.map(a=>this._rect_fitness(a,t,s)!==null?[a.y+s,a.x,t,s,a]:null).filter(a=>a!==null),i=[];this.rot&&(i=this._max_rects.map(a=>this._rect_fitness(a,s,t)!==null?[a.y+t,a.x,s,t,a]:null).filter(a=>a!==null));let r=[...e,...i];if(r.length===0)return[null,null];let[l,h,p,u,c]=r.reduce((a,S)=>S[0]<a[0]?S:a);return[new x(c.x,c.y,p,u),c]}},Et=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},Ft=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:t.width*t.height-s*e}},vt=class extends g{_rect_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}};It.exports={MaxRects:g,MaxRectsBl:Ot,MaxRectsBssf:Et,MaxRectsBaf:Ft,MaxRectsBlsf:vt}});var de=w((qe,Qt)=>{var{GuillotineBssfSas:zt,GuillotineBssfLas:js,GuillotineBssfSlas:zs,GuillotineBssfLlas:Ds,GuillotineBssfMaxas:Ws,GuillotineBssfMinas:Cs,GuillotineBlsfSas:$s,GuillotineBlsfLas:Us,GuillotineBlsfSlas:Ks,GuillotineBlsfLlas:Hs,GuillotineBlsfMaxas:Js,GuillotineBlsfMinas:Qs,GuillotineBafSas:Xs,GuillotineBafLas:Ys,GuillotineBafSlas:Zs,GuillotineBafLlas:Vs,GuillotineBafMaxas:te,GuillotineBafMinas:se}=Rt(),{float2dec:ee,SORT_AREA:Dt,SORT_PERI:ne,SORT_DIFF:ie,SORT_SSIDE:re,SORT_LSIDE:oe,SORT_RATIO:le,SORT_NONE:ce,BinFactory:ae,PackerBNFMixin:he,PackerBFFMixin:ue,PackerBBFMixin:fe,PackerOnline:_e,PackingMode:Wt,PackingBin:Ct,newPacker:$t}=Nt(),{MaxRectsBl:Ut,MaxRectsBssf:Kt,MaxRectsBaf:Ht,MaxRectsBlsf:Jt}=jt();Qt.exports={GuillotineBssfSas:zt,GuillotineBssfLas:js,GuillotineBssfSlas:zs,GuillotineBssfLlas:Ds,GuillotineBssfMaxas:Ws,GuillotineBssfMinas:Cs,GuillotineBlsfSas:$s,GuillotineBlsfLas:Us,GuillotineBlsfSlas:Ks,GuillotineBlsfLlas:Hs,GuillotineBlsfMaxas:Js,GuillotineBlsfMinas:Qs,GuillotineBafSas:Xs,GuillotineBafLas:Ys,GuillotineBafSlas:Zs,GuillotineBafLlas:Vs,GuillotineBafMaxas:te,GuillotineBafMinas:se,MaxRectsBl:Ut,MaxRectsBssf:Kt,MaxRectsBaf:Ht,MaxRectsBlsf:Jt,float2dec:ee,SORT_AREA:Dt,SORT_PERI:ne,SORT_DIFF:ie,SORT_SSIDE:re,SORT_LSIDE:oe,SORT_RATIO:le,SORT_NONE:ce,BinFactory:ae,PackerBNFMixin:he,PackerBFFMixin:ue,PackerBBFMixin:fe,PackerOnline:_e,PackingMode:Wt,PackingBin:Ct,newPacker:$t};typeof window<"u"&&(window.newPacker=$t,window.PackingMode=Wt,window.PackingBin=Ct,window.SORT_AREA=Dt,window.GuillotineBssfSas=zt,window.MaxRectsBl=Ut,window.MaxRectsBssf=Kt,window.MaxRectsBaf=Ht,window.MaxRectsBlsf=Jt)});de();})();
