var Lt=Object.create;var R=Object.defineProperty;var Nt=Object.getOwnPropertyDescriptor;var It=Object.getOwnPropertyNames;var qt=Object.getPrototypeOf,jt=Object.prototype.hasOwnProperty;var b=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),zt=(n,t)=>{for(var s in t)R(n,s,{get:t[s],enumerable:!0})},St=(n,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of It(t))!jt.call(n,i)&&i!==s&&R(n,i,{get:()=>t[i],enumerable:!(e=Nt(t,i))||e.enumerable});return n};var Ot=(n,t,s)=>(s=n!=null?Lt(qt(n)):{},St(t||!n||!n.__esModule?R(s,"default",{value:n,enumerable:!0}):s,n)),Dt=n=>St(R({},"__esModule",{value:!0}),n);var K=b((Gs,kt)=>{var u=class{constructor(t,s){this.x=t,this.y=s}equals(t){return this.x===t.x&&this.y===t.y}toString(){return`P(${this.x}, ${this.y})`}distance(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}distanceSquared(t){return(this.x-t.x)**2+(this.y-t.y)**2}},w=class n{constructor(t,s){if(!(t instanceof u)||!(s instanceof u))throw new Error("Start and end must be Point instances");this.start=t,this.end=s}equals(t){return t instanceof n?this.start.equals(t.start)&&this.end.equals(t.end):!1}toString(){return`S(${this.start}, ${this.end})`}get lengthSquared(){return this.start.distanceSquared(this.end)}get length(){return this.start.distance(this.end)}get top(){return Math.max(this.start.y,this.end.y)}get bottom(){return Math.min(this.start.y,this.end.y)}get right(){return Math.max(this.start.x,this.end.x)}get left(){return Math.min(this.start.x,this.end.x)}},$=class extends w{constructor(t,s){if(!(t instanceof u)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new u(t.x+s,t.y))}get length(){return this.end.x-this.start.x}},U=class extends w{constructor(t,s){if(!(t instanceof u)||typeof s!="number")throw new Error("Start must be a Point and length must be a number");super(t,new u(t.x,t.y+s))}get length(){return this.end.y-this.start.y}},W=class n{constructor(t,s,e,i,r=null){if(i<0||e<0)throw new Error("Height and width must be non-negative");this.width=e,this.height=i,this.x=t,this.y=s,this.rid=r}get bottom(){return this.y}get top(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}get cornerTopL(){return new u(this.left,this.top)}get cornerTopR(){return new u(this.right,this.top)}get cornerBotR(){return new u(this.right,this.bottom)}get cornerBotL(){return new u(this.left,this.bottom)}area(){return this.width*this.height}move(t,s){this.x=t,this.y=s}contains(t){return t.y>=this.y&&t.x>=this.x&&t.y+t.height<=this.y+this.height&&t.x+t.width<=this.x+this.width}intersects(t,s=!1){if(s){if(this.bottom>t.top||this.top<t.bottom||this.left>t.right||this.right<t.left)return!1}else if(this.bottom>=t.top||this.top<=t.bottom||this.left>=t.right||this.right<=t.left)return!1;return!0}intersection(t,s=!1){if(!this.intersects(t,s))return null;let e=Math.max(this.bottom,t.bottom),i=Math.max(this.left,t.left),r=Math.min(this.top,t.top),l=Math.min(this.right,t.right);return new n(i,e,l-i,r-e)}join(t){if(this.contains(t))return!0;if(t.contains(this))return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,!0;if(!this.intersects(t,!0))return!1;if(this.left===t.left&&this.width===t.width){let s=Math.min(this.bottom,t.bottom),e=Math.max(this.top,t.top);return this.y=s,this.height=e-s,!0}if(this.bottom===t.bottom&&this.height===t.height){let s=Math.min(this.left,t.left),e=Math.max(this.right,t.right);return this.x=s,this.width=e-s,!0}return!1}};kt.exports={Point:u,Segment:w,HSegment:$,VSegment:U,Rectangle:W}});var vt=b((Ts,Ft)=>{var{Rectangle:Et}=K(),H=class{constructor(t,s,e=!0,i=null){this.width=t,this.height=s,this.rot=e,this.rectangles=[],this.bid=i,this._surface=new Et(0,0,t,s),this.reset()}get length(){return this.rectangles.length}[Symbol.iterator](){return this.rectangles[Symbol.iterator]()}_fitsSurface(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");if(this.rot&&(t>this.width||s>this.height)){let e=t;t=s,s=e}return!(t>this.width||s>this.height)}getItem(t){return this.rectangles[t]}usedArea(){return this.rectangles.reduce((t,s)=>t+s.area(),0)}fitness(t,s,e=!1){throw new Error("Not implemented")}addRect(t,s,e=null){throw new Error("Not implemented")}rectList(){return this.rectangles.map(t=>[t.x,t.y,t.width,t.height,t.rid])}validatePacking(){let t=new Et(0,0,this.width,this.height);for(let s of this.rectangles)if(!t.contains(s))throw new Error("Rectangle placed outside surface");if(!(this.rectangles.length<=1)){for(let s=0;s<=this.rectangles.length-2;s++)for(let e=s+1;e<=this.rectangles.length-1;e++)if(this.rectangles[s].intersects(this.rectangles[e]))throw new Error("Rectangle collision detected")}}isEmpty(){return this.rectangles.length===0}reset(){this.rectangles=[]}};Ft.exports=H});var yt=b((As,Pt)=>{var{Rectangle:B}=K(),Ct=vt(),$t=n=>class extends n{constructor(t,s,e=!0,i=!0,...r){super(t,s,e,...r),this._merge=i,this._sections=[],this._add_section(new B(0,0,t,s,null))}_add_section(t){t.rid=0;let s=0;for(;this._merge&&this._sections&&s!==this._sections.length;)s=this._sections.length,this._sections=this._sections.filter(e=>!t.join(e));this._sections.push(t)}_split_horizontal(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,t.width,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,e))}_split_vertical(t,s,e){e<t.height&&this._add_section(new B(t.x,t.y+e,s,t.height-e)),s<t.width&&this._add_section(new B(t.x+s,t.y,t.width-s,t.height))}_split(t,s,e){throw new Error("Not implemented")}_section_fitness(t,s,e){throw new Error("Not implemented")}_select_fittest_section(t,s){let e=this._sections.map(f=>{let p=this._section_fitness(f,t,s);return p!==null?[p,f,!1]:null}).filter(f=>f!==null),i=[];this.rot.rot===!0&&(i=this._sections.map(f=>{let p=this._section_fitness(f,s,t);return p!==null?[p,f,!0]:null}).filter(f=>f!==null));let r=[...e,...i];if(r.length===0)return[];let[l,h,M]=r.reduce((f,p)=>p[0]<f[0]?p:f);return[h,M]}addRect(t,s,e=null){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[i,r]=this._select_fittest_section(t,s);if(!i)return null;if(r){let h=t;t=s,s=h}this._sections=this._sections.filter(h=>h!==i),this._split(i,t,s);let l=new B(i.x,i.y,t,s,e);return this.rectangles.push(l),l}fitness(t,s){if(!(t>0&&s>0))throw new Error("Width and height must be positive");let[e,i]=this._select_fittest_section(t,s);return e?i?this._section_fitness(e,s,t):this._section_fitness(e,t,s):null}reset(){super.reset(),this._sections=[],this._add_section(new B(0,0,this.width,this.height))}},Ut=$t(Ct),a=class extends Ut{constructor(...t){super(...t)}},J=class extends a{_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},x=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:t.area()-s*e}},Q=class extends a{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},g=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.max(t.width-s,t.height-e)}},X=class extends a{_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},m=n=>class extends n{constructor(...t){super(...t)}_section_fitness(t,s,e){return s>t.width||e>t.height?null:Math.min(t.width-s,t.height-e)}},S=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width<t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Wt=S(a),Y=class extends Wt{constructor(...t){super(...t)}},O=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width>=t.height?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Kt=O(a),Z=class extends Kt{constructor(...t){super(...t)}},k=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Ht=k(a),V=class extends Ht{constructor(...t){super(...t)}},E=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Jt=E(a),tt=class extends Jt{constructor(...t){super(...t)}},F=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return t.width-s<t.height-e?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Qt=F(a),st=class extends Qt{constructor(...t){super(...t)}},v=n=>class extends n{constructor(...t){super(...t)}_split(t,s,e){return s*(t.height-e)>=e*(t.width-s)?this._split_horizontal(t,s,e):this._split_vertical(t,s,e)}},Xt=v(a),et=class extends Xt{constructor(...t){super(...t)}},Yt=S(m(a)),nt=class extends Yt{constructor(...t){super(...t)}},Zt=O(m(a)),it=class extends Zt{constructor(...t){super(...t)}},Vt=k(m(a)),rt=class extends Vt{constructor(...t){super(...t)}},ts=E(m(a)),ot=class extends ts{constructor(...t){super(...t)}},ss=F(m(a)),ct=class extends ss{constructor(...t){super(...t)}},es=v(m(a)),at=class extends es{constructor(...t){super(...t)}},ns=S(g(a)),lt=class extends ns{constructor(...t){super(...t)}},is=O(g(a)),ht=class extends is{constructor(...t){super(...t)}},rs=k(g(a)),ut=class extends rs{constructor(...t){super(...t)}},os=E(g(a)),ft=class extends os{constructor(...t){super(...t)}},cs=F(g(a)),_t=class extends cs{constructor(...t){super(...t)}},as=v(g(a)),dt=class extends as{constructor(...t){super(...t)}},ls=S(x(a)),pt=class extends ls{constructor(...t){super(...t)}},hs=O(x(a)),Bt=class extends hs{constructor(...t){super(...t)}},us=k(x(a)),xt=class extends us{constructor(...t){super(...t)}},fs=E(x(a)),gt=class extends fs{constructor(...t){super(...t)}},_s=F(x(a)),mt=class extends _s{constructor(...t){super(...t)}},ds=v(x(a)),wt=class extends ds{constructor(...t){super(...t)}};Pt.exports={Guillotine:a,GuillotineBaf:J,GuillotineBlsf:Q,GuillotineBssf:X,GuillotineSas:Y,GuillotineLas:Z,GuillotineSlas:V,GuillotineLlas:tt,GuillotineMaxas:st,GuillotineMinas:et,GuillotineBssfSas:nt,GuillotineBssfLas:it,GuillotineBssfSlas:rt,GuillotineBssfLlas:ot,GuillotineBssfMaxas:ct,GuillotineBssfMinas:at,GuillotineBlsfSas:lt,GuillotineBlsfLas:ht,GuillotineBlsfSlas:ut,GuillotineBlsfLlas:ft,GuillotineBlsfMaxas:_t,GuillotineBlsfMinas:dt,GuillotineBafSas:pt,GuillotineBafLas:Bt,GuillotineBafSlas:xt,GuillotineBafLlas:gt,GuillotineBafMaxas:mt,GuillotineBafMinas:wt}});var At=b((Ws,Tt)=>{var{GuillotineBssfSas:D}=yt();function ps(n,t){return Number(Math.ceil(n*Math.pow(10,t))/Math.pow(10,t))}var Gt=n=>[...n].sort((t,s)=>s[0]*s[1]-t[0]*t[1]),Bs=n=>[...n].sort((t,s)=>s[0]+s[1]-(t[0]+t[1])),xs=n=>[...n].sort((t,s)=>Math.abs(s[0]-s[1])-Math.abs(t[0]-t[1])),gs=n=>[...n].sort((t,s)=>{let[e,i]=[Math.min(t[0],t[1]),Math.max(t[0],t[1])],[r,l]=[Math.min(s[0],s[1]),Math.max(s[0],s[1])];return r-e||l-i}),ms=n=>[...n].sort((t,s)=>{let[e,i]=[Math.max(t[0],t[1]),Math.min(t[0],t[1])],[r,l]=[Math.max(s[0],s[1]),Math.min(s[0],s[1])];return r-e||l-i}),ws=n=>[...n].sort((t,s)=>s[0]/s[1]-t[0]/t[1]),Mt=n=>[...n],P={Online:0,Offline:1,properties:{0:{name:"Online"},1:{name:"Offline"}}},d={BNF:0,BFF:1,BBF:2,Global:3,properties:{0:{name:"BNF"},1:{name:"BFF"},2:{name:"BBF"},3:{name:"Global"}}},G=class{constructor(t,s,e,i,...r){this._width=t,this._height=s,this._count=e,this._packAlgo=i,this._algoArgs=r,this._refBin=null}_createBin(){return new this._packAlgo(this._width,this._height,...this._algoArgs)}isEmpty(){return this._count<1}fitness(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin.fitness(t,s)}fitsInside(t,s){return this._refBin||(this._refBin=this._createBin()),this._refBin._fitsSurface(t,s)}newBin(){return this._count>0?(this._count--,this._createBin()):null}},_=class{constructor({packAlgo:t=D,rotation:s=!0}){this._rotation=s,this._packAlgo=t,this.reset()}*[Symbol.iterator](){yield*[...this._closedBins,...this._openBins]}get length(){return this._closedBins.length+this._openBins.length}_newOpenBin(t=null,s=null,e=null){let i=new Set,r=null;for(let[l,h]of Object.entries(this._emptyBins))if(h.fitsInside(t,s)&&(r=h.newBin(),!!r)){this._openBins.push(r),h.isEmpty()&&i.add(l);break}return i.forEach(l=>delete this._emptyBins[l]),r}addBin(t,s,e=1,i={}){i.rot=this._rotation;let r=new G(t,s,e,this._packAlgo,i);this._emptyBins[this._binCount++]=r}rectList(){let t=[],s=0;for(let e of this){for(let i of e)t.push([s,i.x,i.y,i.width,i.height,i.rid]);s++}return t}binList(){return[...this].map(t=>[t.width,t.height])}validatePacking(){for(let t of this)t.validatePacking()}reset(){this._closedBins=[],this._openBins=[],this._emptyBins=new Map,this._binCount=0}},C=n=>class extends n{constructor({packAlgo:t=D,sortAlgo:s=Mt,rotation:e=!0}={}){super({packAlgo:t,rotation:e}),this._sortAlgo=s,this._availBins=[],this._availRect=[],this._sortedRect=[]}addBin(t,s,e=1,i={}){this._availBins.push([t,s,e,i])}addRect(t,s,e=null){this._availRect.push([t,s,e])}addRectOffline(t,s,e=null){this._availRect.push([t,s,e])}_isEverythingReady(){return this._availRect.length>0&&this._availBins.length>0}pack(){if(this.reset(),!!this._isEverythingReady()){for(let t=0;t<this._availBins.length;t++){let[s,e,i,r]=this._availBins[t];super.addBin(s,e,i,r)}this._sortedRect=this._sortAlgo(this._availRect);for(let t of this._sortedRect)super.addRect(...t)}}},ys=C(_),T=class extends ys{constructor(...t){super(...t)}},y=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(;;){if(this._openBins.length===0&&!this._newOpenBin(t,s,e))return null;let i=this._openBins[0].addRect(t,s,e);if(i)return i;let r=this._openBins.shift();this._closedBins.push(r)}}},Rt=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){for(let i of this._openBins){let r=i.addRect(t,s,e);if(r)return r}for(;;){let i=this._newOpenBin(t,s,e);if(!i)return null;let r=i.addRect(t,s,e);if(r)return r}}},bt=n=>class extends n{constructor(...t){super(...t)}addRect(t,s,e=null){let i=this._openBins.map(r=>[r.fitness(t,s),r]).filter(([r])=>r!==null);if(i.length>0){let[r,l]=i.reduce((h,M)=>M[0]<h[0]?M:h);return l.addRect(t,s,e),!0}for(;;){let r=this._newOpenBin(t,s,e);if(!r)return!1;if(r.addRect(t,s,e))return!0}}},Ms=C(y(_)),A=class extends Ms{constructor(...t){super(...t)}},Rs=C(Rt(_)),L=class extends Rs{constructor(...t){super(...t)}},bs=C(bt(_)),N=class extends bs{constructor(...t){super(...t)}},Ss=y(_),I=class extends Ss{constructor(...t){super(...t)}},Os=Rt(_),q=class extends Os{constructor(...t){super(...t)}},ks=bt(_),j=class extends ks{constructor(...t){super(...t)}},Es=y(T),z=class extends Es{constructor({packAlgo:t=D,rotation:s=!0}={}){super({packAlgo:t,sortAlgo:Mt,rotation:s})}_findBestFit(t){let s=Object.entries(this._sortedRect).map(([r,l])=>[t.fitness(l[0],l[1]),r]).filter(([r])=>r!==null);if(s.length===0)return null;let[e,i]=s.reduce((r,l)=>l[0]<r[0]?l:r);return i}_newOpenBin(t){let s=new Set,e=null;for(let[i,r]of Object.entries(this._emptyBins)){let l=!1;for(let h of Object.values(t))if(r.fitsInside(h[0],h[1])){l=!0;break}if(!l){s.add(i);continue}if(e=r.newBin(),!!e){this._openBins.push(e),r.isEmpty()&&s.add(i);break}}for(let i of s)delete this._emptyBins[i];return e}pack(){if(this.reset(),!!this._isEverythingReady())for(this._sortedRect=Object.fromEntries(this._sortAlgo(this._availRect).map((t,s)=>[s,t]));Object.keys(this._sortedRect).length>0;){let t=this._newOpenBin(this._sortedRect);if(!t)break;for(;;){let s=this._findBestFit(t);if(!s){let i=this._openBins.shift();this._closedBins.push(i);break}let e=this._sortedRect[s];delete this._sortedRect[s],y.prototype.addRect.call(this,...e)}}}};function Fs({mode:n=P.Offline,binAlgo:t=d.BBF,packAlgo:s=D,sortAlgo:e=Gt,rotation:i=!0}={}){let r=null;if(n===P.Online)switch(e=null,t){case d.BNF:r=I;break;case d.BFF:r=q;break;case d.BBF:r=j;break;default:throw new Error("Unsupported bin selection heuristic")}else if(n===P.Offline)switch(t){case d.BNF:r=A;break;case d.BFF:r=L;break;case d.BBF:r=N;break;case d.Global:r=z,e=null;break;default:throw new Error("Unsupported bin selection heuristic")}else throw new Error("Unknown packing mode");return e?new r({packAlgo:s,sortAlgo:e,rotation:i}):new r({packAlgo:s,rotation:i})}Tt.exports={float2dec:ps,SORT_AREA:Gt,SORT_PERI:Bs,SORT_DIFF:xs,SORT_SSIDE:gs,SORT_LSIDE:ms,SORT_RATIO:ws,SORT_NONE:Mt,BinFactory:G,PackerBNFMixin:y,PackerBFFMixin:Rt,PackerBBFMixin:bt,PackerOnline:_,Packer:T,PackerBNF:A,PackerBFF:L,PackerBBF:N,PackerOnlineBNF:I,PackerOnlineBFF:q,PackerOnlineBBF:j,PackerGlobal:z,PackingMode:P,PackingBin:d,newPacker:Fs}});var vs={};zt(vs,{BinFactory:()=>c.BinFactory,GuillotineBafLas:()=>o.GuillotineBafLas,GuillotineBafLlas:()=>o.GuillotineBafLlas,GuillotineBafMaxas:()=>o.GuillotineBafMaxas,GuillotineBafMinas:()=>o.GuillotineBafMinas,GuillotineBafSas:()=>o.GuillotineBafSas,GuillotineBafSlas:()=>o.GuillotineBafSlas,GuillotineBlsfLas:()=>o.GuillotineBlsfLas,GuillotineBlsfLlas:()=>o.GuillotineBlsfLlas,GuillotineBlsfMaxas:()=>o.GuillotineBlsfMaxas,GuillotineBlsfMinas:()=>o.GuillotineBlsfMinas,GuillotineBlsfSas:()=>o.GuillotineBlsfSas,GuillotineBlsfSlas:()=>o.GuillotineBlsfSlas,GuillotineBssfLas:()=>o.GuillotineBssfLas,GuillotineBssfLlas:()=>o.GuillotineBssfLlas,GuillotineBssfMaxas:()=>o.GuillotineBssfMaxas,GuillotineBssfMinas:()=>o.GuillotineBssfMinas,GuillotineBssfSas:()=>o.GuillotineBssfSas,GuillotineBssfSlas:()=>o.GuillotineBssfSlas,PackerBBFMixin:()=>c.PackerBBFMixin,PackerBFFMixin:()=>c.PackerBFFMixin,PackerBNFMixin:()=>c.PackerBNFMixin,PackerOnline:()=>c.PackerOnline,PackingBin:()=>c.PackingBin,PackingMode:()=>c.PackingMode,SORT_AREA:()=>c.SORT_AREA,SORT_DIFF:()=>c.SORT_DIFF,SORT_LSIDE:()=>c.SORT_LSIDE,SORT_NONE:()=>c.SORT_NONE,SORT_PERI:()=>c.SORT_PERI,SORT_RATIO:()=>c.SORT_RATIO,SORT_SSIDE:()=>c.SORT_SSIDE,float2dec:()=>c.float2dec,newPacker:()=>c.newPacker});module.exports=Dt(vs);var o=Ot(yt()),c=Ot(At());0&&(module.exports={BinFactory,GuillotineBafLas,GuillotineBafLlas,GuillotineBafMaxas,GuillotineBafMinas,GuillotineBafSas,GuillotineBafSlas,GuillotineBlsfLas,GuillotineBlsfLlas,GuillotineBlsfMaxas,GuillotineBlsfMinas,GuillotineBlsfSas,GuillotineBlsfSlas,GuillotineBssfLas,GuillotineBssfLlas,GuillotineBssfMaxas,GuillotineBssfMinas,GuillotineBssfSas,GuillotineBssfSlas,PackerBBFMixin,PackerBFFMixin,PackerBNFMixin,PackerOnline,PackingBin,PackingMode,SORT_AREA,SORT_DIFF,SORT_LSIDE,SORT_NONE,SORT_PERI,SORT_RATIO,SORT_SSIDE,float2dec,newPacker});
